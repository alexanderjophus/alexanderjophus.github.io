<!doctype html><html lang=en><head><title>2/4 CREATING A ML CLASSIFIER GRPC SERVICE WITH GOLANG (implementing a server) · Alexander Jophus</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Alexander Jophus"><meta name=description content="DISCLAIMER: This is intending to be a learning exercise and may not be the most efficient way to do things. This is intended to be a multi-part blog post describing how to create a recommender gRPC service in Go.
For the full source code, visit alexanderjophus/iris-classification.
Intro  Link to heading   In this section we&rsquo;re going to implement a gRPC service and test it via manual external tools evans."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="2/4 CREATING A ML CLASSIFIER GRPC SERVICE WITH GOLANG (implementing a server)"><meta name=twitter:description content="DISCLAIMER: This is intending to be a learning exercise and may not be the most efficient way to do things. This is intended to be a multi-part blog post describing how to create a recommender gRPC service in Go.
For the full source code, visit alexanderjophus/iris-classification.
Intro  Link to heading   In this section we&rsquo;re going to implement a gRPC service and test it via manual external tools evans."><meta property="og:title" content="2/4 CREATING A ML CLASSIFIER GRPC SERVICE WITH GOLANG (implementing a server)"><meta property="og:description" content="DISCLAIMER: This is intending to be a learning exercise and may not be the most efficient way to do things. This is intended to be a multi-part blog post describing how to create a recommender gRPC service in Go.
For the full source code, visit alexanderjophus/iris-classification.
Intro  Link to heading   In this section we&rsquo;re going to implement a gRPC service and test it via manual external tools evans."><meta property="og:type" content="article"><meta property="og:url" content="https://example.com/posts/ml-grpc-2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-05T15:37:11+01:00"><meta property="article:modified_time" content="2021-11-05T15:37:11+01:00"><link rel=canonical href=https://example.com/posts/ml-grpc-2/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.5adbe72fc41dcfb852215b84695288939b6b606db73238bd3ee936469572fc9c.css integrity="sha256-WtvnL8Qdz7hSIVuEaVKIk5trYG23Mji9Puk2RpVy/Jw=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q0FK4PHVCM"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-Q0FK4PHVCM',{anonymize_ip:!1})}</script></head><body class="preload-transitions colorscheme-light"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Alexander Jophus</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/sl/>SL</a></li><li class=navigation-item><a class=navigation-link href=https://pokedex.alexanderjophus.dev>Pokédex</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://example.com/posts/ml-grpc-2/>2/4 CREATING A ML CLASSIFIER GRPC SERVICE WITH GOLANG (implementing a server)</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-11-05T15:37:11+01:00>November 5, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
5-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/iris/>iris</a></span></div></div></header><div class=post-content><p>DISCLAIMER: This is intending to be a learning exercise and may not be the most efficient way to do things. This is intended to be a multi-part blog post describing how to create a recommender gRPC service in Go.</p><p>For the full source code, visit <a href=https://github.com/alexanderjophus/iris-classification target=_blank>alexanderjophus/iris-classification</a>.</p><h2 id=intro>Intro
<a class=heading-link href=#intro><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In this section we&rsquo;re going to implement a gRPC service and test it via manual external tools <a href=https://github.com/ktr0731/evans target=_blank>evans</a>.</p><h2 id=setting-up>Setting up
<a class=heading-link href=#setting-up><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>For this we will ignore all machine learning and just get our server returning a random iris classification.
Simple enough.
For this we&rsquo;ll be using <a href=https://github.com/spf13/cobra target=_blank>cobra</a>, a library to help make go executables.
We&rsquo;ll also be adopting some patterns highlighted by Mat Ryers <a href="https://www.youtube.com/watch?v=rWBSMsLG8po" target=_blank>How I write Go Services</a> talk.
Let&rsquo;s start!</p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#fff;font-weight:700>package</span> main

<span style=color:#fff;font-weight:700>import</span> <span style=color:#0ff;font-weight:700>&#34;github.com/alexanderjophus/iris-classification/svc/cmd&#34;</span>

<span style=color:#fff;font-weight:700>func</span> main() {
	cmd.Execute()
}
</code></pre></div><p>Personally I try to keep main as small as possible, it&rsquo;s a hard package to test and reuse, so why stick around in it?
Let&rsquo;s write our Execute function.</p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#fff;font-weight:700>package</span> cmd

<span style=color:#007f7f>// rootCmd represents the base command when called without any subcommands
</span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>var</span> rootCmd = &amp;cobra.Command{
	Use:   <span style=color:#0ff;font-weight:700>&#34;svc&#34;</span>,
	Short: <span style=color:#0ff;font-weight:700>&#34;A service to predict iris classifications&#34;</span>,
	Run:   run,
}

<span style=color:#fff;font-weight:700>func</span> run(cmd *cobra.Command, args []<span style=color:#fff;font-weight:700>string</span>) {}

<span style=color:#007f7f>// Execute adds all child commands to the root command and sets flags appropriately.
</span><span style=color:#007f7f>// This is called by main.main(). It only needs to happen once to the rootCmd.
</span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> Execute() {
	<span style=color:#fff;font-weight:700>if</span> err := rootCmd.Execute(); err != <span style=color:#fff;font-weight:700>nil</span> {
		fmt.Println(err)
		os.Exit(<span style=color:#ff0;font-weight:700>1</span>)
	}
}
</code></pre></div><p>Execute is a minimal function, aiming to just call the cobra commands Execute function.
This gives us a <code>run()</code> function we can test more easily, we also get passed args and the cmd itself should we need them (we won&rsquo;t in this case).
Another thing to highlight is the fields we set in <code>rootCmd</code>, we set the usage name, a short description of what we&rsquo;re doing, and the function to run.
Let&rsquo;s look into that <code>run()</code> function in further detail, we need to set up our server still.</p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#fff;font-weight:700>import</span> (
	pb <span style=color:#0ff;font-weight:700>&#34;github.com/alexanderjophus/iris-classification/proto/gen/go/iris_classification/v1&#34;</span>
	<span style=color:#0ff;font-weight:700>&#34;github.com/alexanderjophus/iris-classification/svc/server&#34;</span>
	<span style=color:#0ff;font-weight:700>&#34;google.golang.org/grpc&#34;</span>
)

<span style=color:#fff;font-weight:700>func</span> run(cmd *cobra.Command, args []<span style=color:#fff;font-weight:700>string</span>) {
	s := server.New()
	grpcS := grpc.NewServer()
	<span style=color:#fff;font-weight:700>defer</span> grpcS.GracefulStop()

	pb.RegisterIrisClassificationServiceServer(grpcS, &amp;s)

	address := <span style=color:#0ff;font-weight:700>&#34;:32400&#34;</span>
	log.Printf(<span style=color:#0ff;font-weight:700>&#34;listening to address %s&#34;</span>, address)
	listener, err := net.Listen(<span style=color:#0ff;font-weight:700>&#34;tcp&#34;</span>, address)
	<span style=color:#fff;font-weight:700>if</span> err != <span style=color:#fff;font-weight:700>nil</span> {
		log.Fatal(err)
	}
	grpcS.Serve(listener)
}
</code></pre></div><p>The first thing we do is create a new server struct <code>s</code> (we&rsquo;ll get around to how that looks next), this code is in another package for separation of concerns.
The next two lines of code are creating a gRPC server, and telling it to shutdown gracefully once we&rsquo;re done.
After that we must register the gRPC server, at this point the code will complain if our server doesn&rsquo;t implement the functions in part 1.
Next we create a port to list on, a listener, and then run <code>grpcS.Serve(listener)</code> this is like <code>http.ListenAndServe</code>, but for gRPC.</p><p>Now we have our cmd package ready to run, let&rsquo;s implement the server.</p><h2 id=implementing-the-server>Implementing the server
<a class=heading-link href=#implementing-the-server><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Let&rsquo;s take a look</p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#fff;font-weight:700>package</span> server

<span style=color:#fff;font-weight:700>import</span> (
	<span style=color:#0ff;font-weight:700>&#34;context&#34;</span>

	pb <span style=color:#0ff;font-weight:700>&#34;github.com/alexanderjophus/iris-classification/proto/gen/go/iris_classification/v1&#34;</span>
)

<span style=color:#007f7f>// New returns a new S
</span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> New() S {
	<span style=color:#fff;font-weight:700>return</span> S{}
}

<span style=color:#007f7f>// S Implements the IrisClassificationService
</span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>type</span> S <span style=color:#fff;font-weight:700>struct</span> {
	pb.UnimplementedIrisClassificationServiceServer
}

<span style=color:#007f7f>// Predict implements proto
</span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> (s *S) Predict(ctx context.Context, req *pb.PredictRequest) (*pb.PredictResponse, <span style=color:#fff;font-weight:700>error</span>) {
	<span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>nil</span>, status.Errorf(codes.Unimplemented, <span style=color:#0ff;font-weight:700>&#34;method Predict not implemented&#34;</span>)
}

</code></pre></div><p>We have a struct <code>S</code>, which is our server, and a <code>New()</code> func to instantiate the struct.
It&rsquo;s important to use the Unimplemented server within our own server, there was a long discussion around pros and cons of implementing it <a href=https://github.com/grpc/grpc-go/issues/3669 target=_blank>here</a>.
It is possible to turn it off, but I&rsquo;d recommend keeping it anyway.
Lastly we have the <code>Predict</code> function, which for the time being we&rsquo;ve just copied the Unimplemented Servers function of <code>Unimplemented</code>.
This is the function we want to eventually predict iris classifications, in the meantime let&rsquo;s just make it return a random classification.</p><p>We can start by defining a var outside our Predict function <code>var irisFlowers = []string{"iris setosa", "iris versicolor", "iris virginica"}</code>.
After that we can use the <a href=https://pkg.go.dev/math/rand target=_blank>rand</a> package to pick a random element from our slice.</p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#007f7f>// Predict implements proto
</span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> (s *S) Predict(ctx context.Context, req *pb.PredictRequest) (*pb.PredictResponse, <span style=color:#fff;font-weight:700>error</span>) {
	rand.Seed(time.Now().Unix()) <span style=color:#007f7f>// initialize global pseudo random generator
</span><span style=color:#007f7f></span>	iris := irisFlowers[rand.Intn(<span style=color:#fff;font-weight:700>len</span>(irisFlowers))]

	<span style=color:#fff;font-weight:700>return</span> &amp;pb.PredictResponse{
		Predicition: iris,
	}, <span style=color:#fff;font-weight:700>nil</span>
}
</code></pre></div><p>Now we should be all done with our server, let&rsquo;s test it.</p><ul><li><code>go run svc/main.go</code></li></ul><p>This gets our service up and running, you should see a log line similar to</p><ul><li><code>2021/11/07 11:54:55 listening to address :32400</code></li></ul><h2 id=introducing-evans>Introducing Evans
<a class=heading-link href=#introducing-evans><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p><a href=https://github.com/ktr0731/evans target=_blank>Evans</a> is a tool to call gRPC services from the command line.
From the root of our repo, run</p><ul><li><code>evans -p 32400 proto/idl/iris_classification/v1/service.proto</code></li></ul><p>From here we can explore our gRPC service through various commands like <code>show</code>, and <code>desc</code>.
After a bit of exploring, we&rsquo;ll run <code>call Predict</code>, this allows us to enter the details of the Request message from our first blog post.
Enter in some random data (it doesn&rsquo;t matter what so long as it&rsquo;s the right type), as we return a random iris classification anyway.
You should see something like this;</p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>iris_classification.v1.IrisClassificationService@127.0.0.1:32400&gt; call Predict
petal_length (TYPE_FLOAT) =&gt; 1.3
petal_width (TYPE_FLOAT) =&gt; 2.1
sepal_length (TYPE_FLOAT) =&gt; 5.6
sepal_width (TYPE_FLOAT) =&gt; 3.4
{
  <span style=color:#0ff;font-weight:700>&#34;predicition&#34;</span>: <span style=color:#0ff;font-weight:700>&#34;iris setosa&#34;</span>
}
</code></pre></div><h2 id=in-summary>In Summary
<a class=heading-link href=#in-summary><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>We have;</p><ul><li>Created a gRPC service</li><li>Tested it runs correctly</li></ul><p>Next we will;</p><ul><li>Create a model for our service to consume</li></ul></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Alexander Jophus
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.369d90111ae4409b4e51de5efd23a46b92663fcc82dc9a0efde7f70bffc3f949.js integrity="sha256-Np2QERrkQJtOUd5e/SOka5JmP8yC3JoO/ef3C//D+Uk="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q0FK4PHVCM"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-Q0FK4PHVCM',{anonymize_ip:!1})}</script></body></html>